import { TtStyleVar } from './tt-style-var';
import { HttpModule, Http, Response, Headers, RequestOptions } from '@angular/http';
import { Injectable } from '@angular/core';

@Injectable()
export class TtStyleService {
  private headers: Headers = new Headers();
  private options: RequestOptions = new RequestOptions();

  constructor(private http: Http) {
    this.headers.append('charset', 'utf-8');
    this.options.headers = this.headers;
  }

  // public methods
  public start(
    templateFileSrc: string,
    templateVars: TtStyleVar[],
    templateMediaQuery?: string
  ) {
    if (this.validateFileSrc(templateFileSrc)) {
      this.http.get(templateFileSrc).map( res => {
        const result: any = res;
        const styleSource = result._body.toString();
        this.createStyle(styleSource, templateVars, templateMediaQuery);
      })
      .subscribe();
    }
  }

  public removeAddedStyles() {
    const elems = document.getElementsByClassName('teme-templater-style');
    // TODO: resolve stupid problem
    for (let i = 0; i < elems.length; i++) {
      elems[i].parentNode.removeChild(elems[i]);
    }
  }

  // private methods
  private createStyle(
    styleSource: string,
    templateVars: TtStyleVar[],
    templateMediaQuery?: string
  ) {
    // Create the <style> tag
    let styleElement = document.createElement('style');
    styleElement = this.replaceVars(styleElement, styleSource, templateVars);

    // Add a media (and/or media query) if defined!
    styleElement = this.addMediaQuery(styleElement, templateMediaQuery);

    // WebKit hack :(
    styleElement.appendChild(document.createTextNode(''));

    // Add class to identify the tag as being generated by this service
    styleElement.setAttribute('class', 'teme-templater-style');

    // Add the <style> element to the page
    document.head.appendChild(styleElement);
  }

  private addMediaQuery(
    styleElement: HTMLStyleElement,
    templateMediaQuery: string
  ) {
    if (typeof templateMediaQuery !== 'undefined' && templateMediaQuery.length > 0) {
      styleElement.setAttribute('media', templateMediaQuery);
    }

    return styleElement;
  }

  private replaceVars(
    styleElement: HTMLStyleElement,
    styleSource: string,
    templateVars: TtStyleVar[]
  ) {
    for (const tvar of templateVars) {
      styleSource = styleSource.split(tvar.VarName).join(tvar.VarValue);
    }
    styleElement.innerHTML = styleSource;

    return styleElement;
  }

  private validateFileSrc(templateFileSrc: string) {
    if (this.getFileExtension(templateFileSrc) !== 'css') {
      this.throwError('The specified source template is not a css file.');
    }
    return true;
  }

  private getFileExtension(templateFileSrc) {
    return templateFileSrc.slice((templateFileSrc.lastIndexOf('.') - 1 >>> 0) + 2);
  }

  private throwError(errorMessage: string, errorType?: string) {
    try {
      switch (errorType) {
        case 'EvalError':
          throw new EvalError(errorMessage);
        case 'RangeError':
          throw new RangeError(errorMessage);
        case 'ReferenceError':
          throw new ReferenceError(errorMessage);
        case 'SyntaxError':
          throw new SyntaxError(errorMessage);
        case 'TypeError':
          throw new TypeError(errorMessage);
        default:
          throw new Error(errorMessage);
      }
    } catch (e) {
      console.log((<Error>e).message); // conversion to Error type
    }
  }
}
